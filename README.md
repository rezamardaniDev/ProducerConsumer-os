<h1>مسئله تولید کننده - مصرف کننده با بافر نامحدود</h1>
<p>
  مسئله تولید کننده - مصرف کننده یک مسئله همگام سازی است که در آن یک یا چند تولید کننده، داده هایی را تولید می کنند و یک یا چند مصرف کننده، این داده ها را مصرف می کنند. برای حل این مسئله با استفاده از بافر نامحدود در C++، می توانید از Semaphore و Thread استفاده کنید.
  </p>
<p>
  در خروجی بافر نامحدود یک صف دوطرفه وجود دارد که به عنوان منبع همگام سازی استفاده می شود. داده ها توسط تولید کننده به صف اضافه شده و توسط مصرف کننده از صف حذف می شوند. در صورتی که صف پر باشد، تولید کننده باید منتظر شود تا مصرف کننده داده ای را از صف حذف کند و برعکس.
  </p>
  <p>
  
تابع producer در این برنامه برای تولید اعداد ایجاد شده است. این تابع با استفاده از یک حلقه برای تولید BUFFER_SIZE عدد، به صورت پشت سر هم، از unique_lock<mutex> برای متزمن کردن منابع استفاده می‌کند. اگر صفحه buffer پر باشد، تولید کننده باید منتظر باشد تا مصرف کننده مواردی را از آن خارج کند تا فضایی برای تولید جدید موجود شود. در این حالت، تولید کننده با فراخوانی produce_cv.wait(lck) از روی condition variable خود، خودش را متوقف می‌کند. هنگامی که فضای کافی برای اضافه کردن یک مورد به صف وجود داشته باشد، تولید کننده یک عدد جدید را به صف اضافه می‌کند و با استفاده از consume_cv.notify_one() منتظر مصرف کننده قرار نمی‌گیرد.
  <br><br>
تابع consumer برای خواندن عدد از صف تولید شده است. همانند producer، این تابع با استفاده از یک حلقه برای خواندن BUFFER_SIZE عدد از صف، از unique_lock<mutex> برای متزمن کردن منابع استفاده می‌کند. اگر buffer خالی بود (که بدان معناست هیچ موردی در آن موجود نیست)، مصرف کننده باید منتظر شود تا تولید کننده موارد جدیدی به صف اضافه کند. در این حالت، مصرف کننده با فراخوانی consume_cv.wait(lck) از روی condition variable خود، خودش را متوقف می‌کند. هنگامی که موردی برای مصرف موجود باشد، مصرف کننده آن را از صف حذف می‌کند و با استفاده از produce_cv.notify_one() منتظر تولید کننده قرار نمی‌گیرد.
  <br><br>
در انتها، سه نخ برای تولید و مصرف ایجاد شده است. با فراخوانی join() برای همه‌ی آن‌ها، برنامه تا زمانی که همه‌ی نخ‌ها به پایان نرسند، منتظر خواهد ماند.
  </p>
